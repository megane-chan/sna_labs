---
title: "Lab 3"
author: "Your Name"
date: today
format: 
  pdf:
      toc: true
      toc-depth: 4
      shift-heading-level-by: 2
      fig-pos: "H"
      fig-cap-location: top
      geometry:
        - top=1in
        - right=.8in
        - bottom=1in
        - left=.8in
      link-citations: true
      linkcolor: blue
      include-in-header: 
        text: |
          \usepackage{fancyhdr}
          \usepackage{titling}
          \pagestyle{fancy}
          \fancyhf{}
          \renewcommand\maketitle{
            \fancyhead[C]{
              \thetitle
              \ifx \theauthor\empty  \else \ – \theauthor \fi
              \ifx \thedate\empty  \else \ – \thedate \ \fi
            }
          }
          \fancyfoot[C]{\thepage}
---

```{r}
#| echo: false
#| output: false
#| message: false

# Clear your environment
rm(list=ls())

# Install packages below if you do not have them:
# -------------------------------------------------
if (!"statnet" %in% installed.packages()) install.packages("statnet") # For fitting ERGMs
if (!"igraph" %in% installed.packages()) install.packages("igraph") # For network plotting
if (!"texreg" %in% installed.packages()) install.packages("texreg") # For printing "nicer" model output

library(statnet)
library(igraph)
library(ggplot2)
library(texreg)

# -----------------------------
# Set the working directory
# Session > Set Working Directory > To Source File Location
# -----------------------------
list.files() # List the files in the current working directory to see if you're in the right directory

```

# Lab 3: Exponential Random Graph Models (ERGMs)

In this lab, we will be testing hypotheses about a network's structure using exponential random graph modeling (ERGM) techniques using the **statnet** package in R. The **statnet** package provides a comprehensive framework for ERGM-based network modeling, including tools for model estimation, model evaluation, model-based network simulation, and network visualization. More documentation about **statnet** is available here: [http://csde.washington.edu/statnet**/**](http://csde.washington.edu/statnet/). More information about ERGM itself can be found in this supplemental lecture video: <https://bit.ly/ERGM_Explanations>. The slides presented in this video are also available on Canvas.

The data used in this lab is from a people analytics project. People analytics refers to the use of HR data to understand behavior in organizations. We will analyze data about the social relations among employees in a small Chinese company. We are interested in understanding who employees go to for advice.

Our dependent variable examines survey responses to the question:

**"List up to 5 employees who you rely on the most for help or advice at work.**"

These responses form a directed network where there is a tie directed from the survey respondent to the person they go to for advice. We provide this data to you in the format of an edgelist, *adviceEdgelist.csv*, in which all 66 employees have been assigned an id ranging from 1 to 66.

Our objective will be to determine what factors influence who someone goes to for advice. We will create a model of this Advice network based on data that is available to the company.

This includes typical HR information, on node attributes, available to them:

● *departmentNode.csv* contains text on which department each employee belongs to.

● *officeNode.csv* contains nodes office locations: 1 for the main office, 0 for the secondary.

● *tenureNode.csv* contains the tenure at the company of each node, in years.

● *leaderNode.csv* contains an indicator (binary) for whether each node is a department lead.

● *femaleNode.csv* contains an indicator variable for sex. 1 for female, 0 for male.

What is unique about this dataset is that we will also look at digital trace data available to the employer. They use an Enterprise Social Media (ESM) platform to allow communication between employees. Enterprise Social Media are social networks developed for work-related use, for example Microsoft Teams or Slack. We have collected data on the number of direct messages employees have sent to one another over roughly six weeks' time. This is shared in the form of an edgelist in *messageEdgelist.csv*.

## **Hypotheses:**

We are going to test the following hypotheses in this lab.

***Hypothesis 1***: There will be indegree popularity effects -- That is, a tendency for a small number of employees to be sought out for advice from many others (as opposed to advice seeking behaviors being spread evenly amongst all employees).

***Hypothesis 2***: Individuals will be more likely to report going to people in their own department, as opposed to other departments, for advice.

***Hypothesis 3***: There will be homophily based upon the sex of individuals, in terms of who employees go to for advice.

***Hypothesis 4***: Employees who message someone more frequently on ESM will be more likely to report going to that person for advice.

***Hypothesis 5***: If an employee *i* goes to another employee *j* for advice, it will be more likely that *j* also goes to employee *i* for advice.

***Hypothesis 6***: Employees who work in the main office will be more likely to go to others for advice than employees from the secondary office.

***Hypothesis 7***: Employees who work in the main office will be more likely to be sought after for advice than employees from the secondary office.

***Hypothesis 8***: Advice seeking relationships tend to be transitive - That is, if individual *i* goes to an individual *k* for advice, and *k* goes to an individual *j* for advice*,* then *i* is more likely to go to *j* for advice as well.

These are the hypotheses that we are interested in testing. However, you will notice that the code for ERGMs you have been provided contains more ERGM terms than just the ones corresponding to the above hypotheses. This is normal -- in testing the hypotheses of interest, we may still want to include additional model terms to act as controls for other factors.

::: {.callout-note style="color: purple"}
Your job is to run the code and, most critically, interpret the output. Test the above hypotheses and prepare the report on your work. Include a copy of the relevant output (model parameters, plots) in your report.
:::

# Part I: Building and Visualizing the Networks (20 pts)

The analysis will use 3 types of files: the "adviceEdgelist.csv" as the *base* *network* file (the ties the model is predicting), "messageEdgelist.csv" as the *covariate network* file, and the remaining csv files as data on *node attributes*. Download all these files into your working directory and load the network and attribute data.

```{r}
#| echo: false
#| output: false
#| message: false

# First we will load in the adviceEdgelist.csv file, which contains our dependent
# variable. These are responses to the question:
# “List up to 5 employees who you rely on the most for help or advice at work.” 
# Note that participants were limited to selecting at most five respondents.
adviceEdgelist <- read.csv("adviceEdgelist.csv")
# View the first rows of the edgelist to make sure it imported correctly:
head(adviceEdgelist)
# Convert the edgelist to a network object in statnet format:
advice <- as.network.matrix(adviceEdgelist, matrix.type = "edgelist") 
# View a summary of the network object
advice
# Independent variables:
# Load node attributes, and store them in the advice network object we have created
advice |> network::set.vertex.attribute("department", 
                          value = read.csv("departmentNode.csv")$department) # Categorical variable for department

advice |> network::set.vertex.attribute("leader",read.csv("leaderNode.csv")$leader) # Indicator variable for department leader
advice |> network::set.vertex.attribute("tenure",read.csv("tenureNode.csv")$tenure) # Years tenure
advice |> network::set.vertex.attribute("office",read.csv("officeNode.csv")$office) # Indicator variable for whether they are located in the main or secondary office
advice |> network::set.vertex.attribute("female",read.csv("femaleNode.csv")$female) # Indicator variable for female vs. male
advice # These five variables should now be listed as vertex attributes when viewing the summary of the network
```

```{r}
#| echo: false
#| output: false

# Double-check the values for all of the node variables
network::get.vertex.attribute(advice,"department")
network::get.vertex.attribute(advice,"leader")
network::get.vertex.attribute(advice,"tenure")
network::get.vertex.attribute(advice,"office")
network::get.vertex.attribute(advice,"female")
```

```{r}
#| echo: false
#| output: false

# Finally, we will import data on the counts of direct messages sent between two employees
# The file "messageEdgelist.csv" contains a messaging edgelist, that we will convert to a matrix
# Statnet allows adjacency matrices with valued ties to be used as predictors (edge covariates) in ERGMs
messageEdgelist <- read.csv("messageEdgelist.csv")
head(messageEdgelist) # Check the first five rows of the edgelist. Third column is the message count
messages <- matrix(nrow = 66, ncol = 66) # Number of Direct messages sent from i to j
for (i in 1:nrow(messageEdgelist)) { # Read from edgelist
  messages[messageEdgelist$SenderId[i], messageEdgelist$ReceiverId[i] ] <- as.numeric(messageEdgelist$MessagesSent[i])
}
for (i in 1:66) { # Remove self-ties (messages sent to self)
  messages[i,i] <- as.numeric(0)
}
hundreds_messages <- messages / 100 # Change weights to represent hundred of messages sent
                                   # This will make viewing/interpreting ergm coefficients easier

# ---------------------------------------------------------------------------------------
# Basic descriptive information
# ---------------------------------------------------------------------------------------
summary(advice, print.adj = FALSE)           # summarize the advice From You network
```

## 1. Describe the data that you are analyzing. **(5 pts)**

#### What network(s) are you analyzing? What edge or vertex attributes are stored? Are there any limitations to the data or assumptions based on how it was collected?

## 2. Plot the base (Advice) network and interpret the visualization. **(5 pts)**

#### Explain whether this plot *seems*, at a glance, to match what you would expect to see if hypothesis 1 were true. Think of this as just a basic descriptive check -- we will perform a more rigorous statistical test in part II of the lab.

```{r}
#| echo: false
#| message: false 
# Ignore messages on any objects that are masked

# Set default plot options
igraph_options(vertex.size = 12, vertex.color = 'grey', # vertex.size changes the size of nodes; vertex.color changes the color of nodes
               edge.color='gray80', edge.arrow.size=.1, # edge.color changes the color of ties; edge.arrow.size changes the size of tie arrow heads
               vertex.label = NA)                       # vertex.label = NA specifies not to display vertex labels in the plot

# Plot the Advice network
advice_igraph <- graph_from_adjacency_matrix(as.matrix.network(advice)) # make an igraph network object from statnet network object
advice_igraph <- set_vertex_attr(advice_igraph,"female",value = read.csv("femaleNode.csv")$female)
net_layout <- layout_with_kk(advice_igraph) # Calculates and stores a spring-embedded layout

# We will re-use this same layout for each plot, so nodes are always in the same place
plot(advice_igraph, layout=net_layout, edge.color='black', 
     vertex.label = V(advice_igraph),
     vertex.label.cex = 0.5,
     margin=0
     )
```

## 3. Plot the base network with the nodes now colored based on sex and interpret the new visualization. **(5 pts)**

#### Explain whether this plot seems to match what you would expect to see if hypothesis 3 were true.

```{r}
#| echo: false
#| message: false 

# Plot the Advice network with node coloring based on sex
V(advice_igraph)$color = ifelse (V(advice_igraph)$female ==1, " orange ", " grey ")
plot(advice_igraph, 
     layout=net_layout, 
     edge.color='black', 
     vertex.label = V(advice_igraph),
     vertex.label.cex = 0.5,
     margin=0)
```

## 4. Plot the covariate network and interpret this visualization. **(5 pts)**

#### Comparing the network plots, explain whether this plot seems to match what you would expect to see if hypothesis 4 were true.

```{r}
#| echo: false
#| message: false 

# Plot the network of who messages whom
# One unit of weight is 100 messages
messages_igraph <- graph_from_adjacency_matrix(messages, weighted = TRUE) ## weighted = TRUE creates edge weight in the igraph object
## below because it is added not only edge weight, but also changed the transparency of edges, it will take more time to plot
## also, if you use zoom in RStudio, it may take about 1 minute until you see the plot.
plot(messages_igraph, 
     layout=net_layout, 
     edge.color = adjustcolor('blue',alpha=.2), 
     vertex.label = V(advice_igraph), 
     vertex.label.cex = 0.5,
     margin=0,
     edge.width=log(E(messages_igraph)$weight), 
     edge.arrow.width =.2)
```

# Part II: Model Estimation (50 pts)

## 1. Build two ERGM models to test the hypotheses using the different network statistics described below **(10 pts)**

```{r}
#| echo: false
#| message: false 
#| output: false

# R vignette for more details: https://cran.r-project.org/web/packages/ergm/ergm.pdf

options(ergm.loglik.warn_dyads=FALSE) #Whether or not a warning should be issued when sample space constraints render the observed number of dyads ill-defined

# Ergm Terms are statistics: They are some deterministic function of the ties, node attributes, and edge covariates of a network.
help("ergm-terms",package = "ergm") # Documentation that contains definitions for all of the terms we are using
                                    # ex. what does "mutual" test and how is it calculated
# We will use the ergm-terms to perform hypothesis testing using ERGMs
# But we can note that any of the ERGM terms can also be examined directly for your observed network, by creating a formula in R

# Look at Endogenous statistics: terms based on only ties in the advice network
summary(advice ~ edges)                     # Number of edges (ties)
summary(advice ~ mutual)                    # Number of pairs of reciprocated ties
summary(advice ~ odegree(0:5))              # Outdegree distribution. (# of nodes with outdegree of 0, # nodes outdegree of 1, etc.)
                                           # Remember, respondents could nominate at most five employees in our survey
summary(advice ~ idegree(0:65))             # Indegree distribution.
summary(advice ~ gwodegree(log(2),fixed=T)) # One parameter summarizing outdegree distribution - tendency against outdegree hubs
summary(advice ~ gwidegree(log(2),fixed=T)) # One parameters summarizing indegree distribution - tendency against indegree hubs
summary(advice ~ desp(1:5))                 # Pairs of nodes with one shared partner, two shared partners, etc.
summary(advice ~ dgwesp(log(2),fixed = T))  # One parameter summarizing 

# Look at Exogenous statistics: terms based on advice ties AND other ties / node attributes
summary(advice ~ nodeicov("office"))             # Ties directed towards employees at the main office (as opposed to secondary office)
summary(advice ~ nodeocov("office"))             # Ties originating from employees at the main office (as opposed to secondary office)
summary(advice ~ nodematch("female"))            # Number of ties between people of the same sex
summary(advice ~ nodematch("department"))        # Number of ties between people working in the same department
summary(advice ~ nodemix("leader",levels2=NULL)) # Number of ties between different combinations of leaders(1) and non-leaders(0)
summary(advice ~ diff("tenure"))                 # Total difference in tenure: sum of (sender's tenure - receivers-tenure) for all ties
summary(advice ~ edgecov(hundreds_messages))     # Total messages sent: sum of (messages sent from sender to receiver)/100 for all Advice ties
                                                # e.g., a total of 5669 messages were sent from employees to those they go to for advice during the observed period

# The above are statistics - counts of these patterns for our networks
# What fitting the ERGM model will tell is whether these counts are relatively high/low
# in comparison to what we would expect based on random chance, controlling for the other effects in our model.
# This type of analysis can be helpful for understanding your network, as well as troubleshooting issues with ERGM regression
```

#### Look at the endogenous and exogenous summary statistics. Based on these values, how many pairs of advice-seeking ties were reciprocated? How many advice-seeking ties originated from the main office?

::: {.callout-note style="color: purple"}
Fit model 1 (simple model) and model 2 (complex model) using the terms already specified in the R script provided to you. We will start with the simple model.
:::

#### What model constraints were defined in both models and why?

```{r}
#| echo: false
#| message: false

# The following commands do model estimation for ERGMs.
# This may take a second. Text will print in-console to update you on progress in model estimation.
model1 <- ergm(advice ~ edges                 # This is  a tendency towards a greater number of advice ties existing. Based on a statistic counting the number of ties.
               # Structural patterns
               + mutual                      # This is a tendency towards reciprocity for the advice ties. Based on a statistic counting the number of reciprocated ties.
               + edgecov(hundreds_messages)  # This is the effect of every 100 messages sent from i->j on likelihood of an advice tie. Based on a weighted sum of advice ties x 100s of messages sent
               + nodemix("leader",base = 3)
               # Model constraints
               , constraints =~ bd(maxout=5) # This constraint enforces the maximum outdegree is 5
               , control = control.ergm(seed = 42)
               ,verbose = F
)
summary(model1) 

## Convert a log-odds (e.g., -0.68122) ratio to an odds ratio
# exp(-0.68122)
```

::: {.callout-note style="color: purple"}
Now we will fit a more complex model.
:::

#### What parameter was included in the simple model but not in the complex model?

```{r}
#| echo: false
#| message: false ## make it true, if you want to see cool messages about Convergence process iterations
#| warning: false
model2 <- ergm(advice ~  # This model will be slower to estimate than model 1
                        # Expect roughly 2-7 minutes. If it gets stuck for longer than that, try hitting "stop" and re-running it
               # Structural patterns
               # edges
               mutual
               + gwidegree(log(2), fixed = T)                 # Inverted preferential attachment (indegree)
               + gwodegree(2, fixed = T, cutoff = 5)              # Inverted preferential attachment (outdegree)
               + dgwesp(log(2), type = "OTP", fixed = T, cutoff =5)    # A modified version of Outgoing Two Path(i->j + i->k->j) structures. Geometrically weighted version of transitivity
               # Node attribute effects
               + nodematch("female")                                   # Homophily on a categorical variable 
               + nodemix("leader", base = 3)                           # Mixing matrix of all different combinations of node attributes (ex. A -> A ties, A-> B ties, B -> A ties, B -> B ties). 
               + nodematch("department") 
               + nodeicov("office")                                    # Covariance between in-degree of nodes and attributes of nodes
               + nodeocov("office")                                    # Covariance between out-degree of nodes and attributes of nodes
               + diff("tenure")                                        # Difference is computed as (tenure_i - tenure_j) i: sending node, j: receiving node
               + edgecov(hundreds_messages)                            # Covariance between edges of two networks (predictor can be continous)
               # Constraints on network
               , constraints =~ bd(maxout=5)                           # This constraint enforces the maximum outdegree is 5
               # Control settings for MCMC-MLE algorithm
               , control = control.ergm(MCMC.effectiveSize = 50, 
                                        seed = 42)
) 
summary(model2) 
```

## 2. For each of the eight hypotheses, interpret the results from your models and state whether that hypothesis was supported. **(40 pts)**

#### To determine whether a hypothesis is supported, look at whether there is a p-value \< 0.05 and the directionality (positive/negative) of the effect. When you interpret the results, convert the model coefficients, which are given by R as conditional log-odds, into odds ratios.

```{r}
#| echo: false

# Easy side-by-side model comparison:
texreg::screenreg(list("model1"=model1,"model2"=model2))
```

### Hypothesis 1

### Hypothesis 2

### Hypothesis 3

### Hypothesis 4

### Hypothesis 5

### Hypothesis 6

### Hypothesis 7

### Hypothesis 8

# Part III: Model Diagnostics (30 pts)

You can judge convergence of the MCMC process in the models using the *mcmc.diagnostics()* function. The function will plot the change of model statistics during the last iteration of the MCMC estimation procedure. For each model statistic, the left-hand side plot gives the change of the statistic with iterations, and the right-hand side plot is a histogram of the statistic values. Both are normalized, so the observed values are located at 0.

## 1. Attach the model diagnostics for model 1 and 2 in your report and interpret the plots. Has the MCMC process converged to a desired state? **(10 pts)**

### MCMC Model 1

```{r}
#| echo: false

par(mar=c(1,1,1,1))
mcmc.diagnostics(model1, 
                 which="plots" # this command produces only the output plots
                 # if you are curious about other mcmc diagnostics you can uncomment the line above.
                 )
```

### MCMC Model 2

```{r}
#| echo: false

par(mar=c(1,1,1,1))
mcmc.diagnostics(model2, 
                 which="plots" # this command produces only the output plots
                 # if you are curious about other mcmc diagnostics you can uncomment the line above.
                 )
```

## 2. Perform Goodness of Fit test to check how well the estimated model captures certain statistical features of the observed network for both model 1 and 2. **(10 pts)**

a.  To do so, simulate many networks from the estimated model and extract 100 samples from the simulation process. Please note, this may take 2 minutes or more to compute.

#### Compare the plots generated. Identify which network visualizations were generated from model 1 vs. model 2 and describe any similarities / differences you can see.

```{r}
#| echo: false
#| warning: false

# -------------------------------------------------------------------------------------------------
# Goodness of fit test - will display in RStudio
# Check how well the estimated model captures certain features of the observed network, for example triangles in the network.
# -------------------------------------------------------------------------------------------------
# Look at networks simulated according to model 1
# This first command simulates 100 networks.
# These networks, if we use sufficient burnin steps in the markov chain used to generate them,
# may be thought of as random samples from the joint probability distribution that is our fitted ERGM.
sim1 <- simulate(model1, burnin=100000, interval=100000, nsim=100, verbose=T)  # Uses the ergm model to simulate a null model
# Plot the first of the simulated networks
sim1_net1 <- igraph::graph.adjacency(as.matrix.network(sim1[[1]]))
igraph::plot.igraph(sim1_net1,layout=net_layout,edge.color="brown",  
                    vertex.color = 'grey',edge.arrow.size=.1)

# Plot the 10th simulated network
sim1_net10 <- igraph::graph.adjacency(as.matrix.network(sim1[[10]]))
igraph::plot.igraph(sim1_net10,layout=net_layout,edge.color="red",  
                    vertex.color = 'grey',edge.arrow.size=.1)


# Repeat, now looking at networks simulated according to model 2
sim2 <- simulate(model2, burnin=100000, interval=100000, nsim=100, verbose=T)  # Uses the ergm model to simulate a null model
# Plot the first of the simulated networks
sim2_net1 <- igraph::graph.adjacency(as.matrix.network(sim2[[1]]))
igraph::plot.igraph(sim2_net1,layout=net_layout,edge.color="grey",  
                    vertex.color = 'grey',edge.arrow.size=.1)                                                               
# Plot the 10th simulated network
sim2_net10 <- igraph::graph.adjacency(as.matrix.network(sim2[[10]]))
igraph::plot.igraph(sim2_net10,layout=net_layout,edge.color="purple",  
                    vertex.color = 'grey',edge.arrow.size=.1)
```

b.  Extract the number of triangles from each of the 100 samples.

#### How many triangles were observed in the advice seeking network? What was the mean value of triangles generated by model 1? What about in model 2?

```{r}
#| echo: false

# Observed network:
advice.tri <- summary(advice ~ triangle)                                  # Stores the number of observed triangles
advice.tri

print("Model 1")
model1.tridist <- sapply(1:100, function(x) summary(sim1[[x]] ~triangle)) # Extracts the triangle data from the simulated networks
c(obs=advice.tri,mean=mean(model1.tridist),sd=sd(model1.tridist),
  tstat=abs(mean(model1.tridist)-advice.tri)/sd(model1.tridist))

print("Model 2")
model2.tridist <- sapply(1:100, function(x) summary(sim2[[x]] ~triangle)) # Extracts the triangle data from the simulated networks
c(obs=advice.tri,mean=mean(model2.tridist),sd=sd(model2.tridist),
  tstat=abs(mean(model2.tridist)-advice.tri)/sd(model2.tridist))
```

c.  Compare the distribution of triangles in the sampled networks with the observed network by generating a histogram of the triangles. 

#### Interpret your result. Are either of the models good in terms of triangle measure?

```{r}
#| echo: false

# Model 1:
#Plots that triangle distribution as a histogram
model1.tridist |> 
  as.data.frame() |> 
  ggplot(aes(x = model1.tridist)) +
  geom_histogram(binwidth = 10, fill = "lightblue", color = "black") +
  geom_boxplot(fill = "grey")+
  geom_vline(xintercept = advice.tri, color = "red", linewidth = 1.5) +
  geom_text(aes(x = advice.tri, y = 10, label = paste("Observed:", advice.tri)), color = "red", vjust = -1, angle = 90) +
  labs(title = "Distribution of Triangles in Model 1",
       x = "Number of Triangles",
       y = "Frequency") +
  theme_minimal()


# Model 2:
hist(model2.tridist,xlim=c(0,1000),breaks=10)                             # Plots that triangle distribution as a histogram, change xlim to change the x-axis range if necessary
arrows(advice.tri,20, advice.tri, 0.5, col="red", lwd=3)   
model2.tridist |> 
  as.data.frame() |> 
  ggplot(aes(x = model2.tridist)) +
  geom_histogram(binwidth = 10, fill = "lightblue", color = "black") +
  geom_boxplot(fill = "grey")+
  geom_vline(xintercept = advice.tri, color = "red", linewidth = 1.5) +
  geom_text(aes(x = advice.tri, y = 10, label = paste("Observed:", advice.tri)), color = "red", vjust = -1, angle = 90) +
  labs(title = "Distribution of Triangles in Model 2",
       x = "Number of Triangles",
       y = "Frequency") +
  theme_minimal()
```

## 3. Perform a goodness-of-fit evaluation process for a variety of other network statistics just for model 2 **(10 pts)**

*for example, degree distribution, distribution of edgewise shared partners, and the distribution of geodesics* Simulate networks, compile statistics for these simulations as well as the observed network, and calculate p-values of all of the aforementioned values to evaluate the correspondence between the networks simulated by the model and the observed network. Report the p-values for the simulation and interpret them.

::: {.callout-note style="color: purple"}
Below we provide sample code to perform a goodness of fit evaluation for model 1. Modify the code as necessary to perform the goodness of fit test for model 2.

Note: Your gof graph should have 5 subplots corresponding to the 5 parameters of your model. The dark black line represents the data for the observed network. The boxplots represent the distribution of corresponding degrees across the simulated networks, and the soft lines are the 95% confidence intervals. In general, for configurations in the model, the fit is considered good if │t│≤ 0.1. For configurations not included in the model, the fit is considered good if 0.1\<│t│≤ 1, and not extreme if 1\<│t│≤ 2. If │t│\> 2 the fit is bad.
:::

### Model 1 GOF

```{r}
#| warning: false
# -------------------------------------------------------------------------------------------------
# Test the goodness of fit of the model
# Compiles statistics for these simulations as well as the observed network, and calculates p-values 
# -------------------------------------------------------------------------------------------------

# Model 1:
# It may take a second for this command to run.
gof1 <- gof(model1, verbose=T, burnin=1e+5, interval=1e+5, control = control.gof.ergm(nsim = 200))
# If you run below and then wouldn't see the plot, trypar(mar=c(2,2,2,2))
# dev.off()           # Clear any other plots from the plot window
plot(gof1)          # Plot the goodness of fit
                    # Note: This should produce five separate plots that you should look through.
                    #       In RStudio, scroll between the plots using the arrow buttons
gof1                # Display the goodness of fit info in the console
```


### Model 2 GOF

```{r}

```


## Disclose AI Use

I used ... to generate ... for this lab

------------------------------------------------------------------------

Check your submission for grammar - points may be deducted for lack of clarity.

Click 'Render' button at the top of the screen, or press cmd + shift + k. Note. It might take some time for you computer to render this document as a PDF, since it will be running all code chunks.

Deliverables to submit on Canvas:

1.  Your report as a .pdf file
2.  Your code as a .qmd file
3.  Your data as a .RData file

```{r}
save.image(file = "lab3.RData")
```

Please upload each file separately -- do not upload as a zip file! *(Please)*

### Endogenous Effects (Effects of the ties being predicted on other predicted ties)

● ***edges***: number of edges in the network

● ***mutual***: number of reciprocal edges in the network

● ***gwidegree***: Geometrically Weighted Indegree. This term measures a tendency *against* indegree preferential attachment. (Negative coefficients show indegree preferential attachment -- Incoming ties are more likely to be directed towards nodes that already have other incoming ties.)

● ***gwodegree***: Directed Geometrically Weighted Outdegree. This term measures a tendency *against* outdegree preferential attachment. (Negative coefficients show outdegree preferential attachment -- Outgoing ties are more likely to originate from nodes that already have other outgoing ties)

● ***dgwesp***, of type "OTP": *Directed Geometrically Weighted Edgewise Shared Partners* Number of edges that belong to certain types of triangles. "Edgewise" refers to the fact that we require a tie to exist between nodes i and j, and then measure the number of "shared partners" between them. Shared partners are nodes that have a certain relationship between i and j. In this case, we are looking at the Outgoing Two Path ("OTP") relationships. This is one way to operationalize transitivity. The "geometrically weighted" refers to the fact that we will use a weight parameter,, to add diminishing returns to the number of shared partners (i.e., the second shared partner between two nodes will have less effect on the likelihood of a network than the first shared partner, the third will have even less of an effect, and so on).

Yes, geometrically weighted terms (gwidegree, gwodegree, dgwesp) are very complicated. Essentially, the "geometric weighted" part is saying that effects on network probability have diminishing returns for nodes as degree or the number of shared partners gets higher and higher. This helps avoid model fits where all the ties are directed towards one node. For the purposes of this class, you can ignore the technical details and just focus on interpreting them in terms of "preferential attachment" or "transitivity" effects.

### **Exogenous Effects (Effects of node attributes or variables outside the predicted ties)**

● ***nodeicov***: covariance between in-degree of nodes and attributes of nodes

● ***nodeocov***: covariance between out-degree of nodes and attributes of nodes

● ***diff***: differences between nodes on some numeric attribute (ex. tenure, age). The way we have it specified in the code, diff scores are is calculated as the attribute value of the sending node (attb~i~) minus value of the receiving node (attb~j~). (Heterophily/ anti-homophily on continuous variables).

● ***nodematch***: tendency of nodes to form ties with those of matching values (Homophily on categorical variables)

● ***nodemix***: mixing matrix of all different combinations of node attributes (ex. A -\> A ties, A-\> B ties, B -\> A ties, B -\> B ties). To avoid model overspecification, we need to leave one of these cells out of the model. The weights (effect sizes) estimated for all of the terms we leave in the model then represent the effect of a combination relative to the effect that we left out.

● ***edgecov***: covariance between edges of two networks (the presence/strength of a tie in an outside network on whether a tie exists in our dependent variable network -- Advice)
